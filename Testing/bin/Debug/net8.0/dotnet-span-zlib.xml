<?xml version="1.0"?>
<doc>
    <assembly>
        <name>dotnet-span-zlib</name>
    </assembly>
    <members>
        <member name="T:ConMaster.Compression.InternalCompressor">
            <summary>
            Internal Compressor, Should be internaly inherited only
            </summary>
        </member>
        <member name="P:ConMaster.Compression.InternalCompressor.CompressionLevel">
            <summary>
            Compression Level
            </summary>
        </member>
        <member name="P:ConMaster.Compression.InternalCompressor.MemoryLevel">
            <summary>
            Memory Level 
            [1..9]
            1 - Lowest memory usage, slow - low compression ratio
            9 - Hight memory usage, fast - hight compression ratio
            </summary>
        </member>
        <member name="M:ConMaster.Compression.InternalCompressor.Compress(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Compression Algorithm
            </summary>
            <param name="source">Source buffer to operate compression on</param>
            <param name="destination">Target buffer to write compression results to</param>
            <returns>The length of compressed data in destination</returns>
        </member>
        <member name="M:ConMaster.Compression.InternalCompressor.CompressToSpan(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Compression Algorithm
            </summary>
            <param name="source">Source buffer to operate compression on</param>
            <param name="destination">Target buffer to write compression results to</param>
            <returns>Span with length of compressed data, slice from destination span</returns>
        </member>
        <member name="M:ConMaster.Compression.InternalCompressor.Compress(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
            <summary>
            Compression Algorithm
            </summary>
            <param name="source">Source buffer to operate compression on</param>
            <param name="destination">Target buffer to write compression results to</param>
            <param name="bytesWritten">Number of bytes written to destination span</param>
        </member>
        <member name="M:ConMaster.Compression.InternalCompressor.Decompress(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Dempression Algorithm
            </summary>
            <param name="source">Source buffer to operate decompression on</param>
            <param name="destination">Target buffer to write decompression results to</param>
            <returns>The length of decompressed data in destination</returns>
        </member>
        <member name="M:ConMaster.Compression.InternalCompressor.DecompressToSpan(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Dempression Algorithm
            </summary>
            <param name="source">Source buffer to operate decompression on</param>
            <param name="destination">Target buffer to write decompression results to</param>
            <returns>Span with length of decompressed data, slice from destination span</returns>
        </member>
        <member name="M:ConMaster.Compression.InternalCompressor.Decompress(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)">
            <summary>
            Dempression Algorithm
            </summary>
            <param name="source">Source buffer to operate decompression on</param>
            <param name="destination">Target buffer to write decompression results to</param>
            <param name="bytesWritten">Number of bytes written to destination span</param>
        </member>
        <member name="M:ConMaster.Compression.InternalCompressor.Crc32(System.ReadOnlySpan{System.Byte},System.UInt32)">
            <summary>
            Basic C3C hashing algorithm
            </summary>
            <param name="source">Source buffer to operate hasing on</param>
            <param name="token">Source token to use for hasing</param>
            <returns>Hashing results</returns>
        </member>
        <member name="T:ConMaster.Compression.DeflateCompressor">
            <summary>
            Raw Deflate Compression Algorithm - No Headers
            </summary>
        </member>
        <member name="M:ConMaster.Compression.DeflateCompressor.#ctor">
            <summary>
            Raw Deflate Compression Algorithm - No Headers
            </summary>
        </member>
        <member name="M:ConMaster.Compression.DeflateCompressor.Compress(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:ConMaster.Compression.DeflateCompressor.Decompress(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="T:ConMaster.Compression.ZLibCompressor">
            <summary>
            Deflate Compression Algorithm - With zlib header
            </summary>
        </member>
        <member name="M:ConMaster.Compression.ZLibCompressor.#ctor">
            <summary>
            Deflate Compression Algorithm - With zlib header
            </summary>
        </member>
        <member name="T:ConMaster.Compression.GZipCompressor">
            <summary>
            Deflate Compression Algorithm - With gzib header
            </summary>
        </member>
        <member name="M:ConMaster.Compression.GZipCompressor.#ctor">
            <summary>
            Deflate Compression Algorithm - With gzib header
            </summary>
        </member>
        <member name="T:ConMaster.Compression.CompressionLevel">
             <summary>
             <p>ZLib can accept any integer value between 0 and 9 (inclusive) as a valid compression level parameter:
             1 gives best speed, 9 gives best compression, 0 gives no compression at all (the input data is simply copied a block at a time).
             <code>CompressionLevel.DefaultCompression</code> = -1 requests a default compromise between speed and compression
             (currently equivalent to level 6).</p>
            
             <p><strong>How to choose a compression level:</strong></p>
            
             <p>The names <code>NoCompression</code>, <code>BestSpeed</code>, <code>DefaultCompression</code>, <code>BestCompression</code> are taken over from
             the corresponding ZLib definitions, which map to our public NoCompression, Fastest, Optimal, and SmallestSize respectively.</p>
             <p><em>Optimal Compression:</em></p>
             <p><code>ZLibNative.CompressionLevel compressionLevel = ZLibNative.CompressionLevel.DefaultCompression;</code> <br />
                <code>int windowBits = 15;  // or -15 if no headers required</code> <br />
                <code>int memLevel = 8;</code> <br />
                <code>ZLibNative.CompressionStrategy strategy = ZLibNative.CompressionStrategy.DefaultStrategy;</code> </p>
            
            <p><em>Fastest compression:</em></p>
            <p><code>ZLibNative.CompressionLevel compressionLevel = ZLibNative.CompressionLevel.BestSpeed;</code> <br />
               <code>int windowBits = 15;  // or -15 if no headers required</code> <br />
               <code>int memLevel = 8; </code> <br />
               <code>ZLibNative.CompressionStrategy strategy = ZLibNative.CompressionStrategy.DefaultStrategy;</code> </p>
            
             <p><em>No compression (even faster, useful for data that cannot be compressed such some image formats):</em></p>
             <p><code>ZLibNative.CompressionLevel compressionLevel = ZLibNative.CompressionLevel.NoCompression;</code> <br />
                <code>int windowBits = 15;  // or -15 if no headers required</code> <br />
                <code>int memLevel = 7;</code> <br />
                <code>ZLibNative.CompressionStrategy strategy = ZLibNative.CompressionStrategy.DefaultStrategy;</code> </p>
            
             <p><em>Smallest Size Compression:</em></p>
             <p><code>ZLibNative.CompressionLevel compressionLevel = ZLibNative.CompressionLevel.BestCompression;</code> <br />
                <code>int windowBits = 15;  // or -15 if no headers required</code> <br />
                <code>int memLevel = 8;</code> <br />
                <code>ZLibNative.CompressionStrategy strategy = ZLibNative.CompressionStrategy.DefaultStrategy;</code> </p>
             </summary>
        </member>
        <member name="T:ConMaster.Compression.CompressionStrategy">
             <summary>
             <p><strong>From the ZLib manual:</strong></p>
             <p><code>CompressionStrategy</code> is used to tune the compression algorithm.<br />
             Use the value <code>DefaultStrategy</code> for normal data, <code>Filtered</code> for data produced by a filter (or predictor),
             <code>HuffmanOnly</code> to force Huffman encoding only (no string match), or <code>Rle</code> to limit match distances to one
             (run-length encoding). Filtered data consists mostly of small values with a somewhat random distribution. In this case, the
             compression algorithm is tuned to compress them better. The effect of <code>Filtered</code> is to force more Huffman coding and]
             less string matching; it is somewhat intermediate between <code>DefaultStrategy</code> and <code>HuffmanOnly</code>.
             <code>Rle</code> is designed to be almost as fast as <code>HuffmanOnly</code>, but give better compression for PNG image data.
             The strategy parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set
             appropriately. <code>Fixed</code> prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications.</p>
            
             <p><strong>For .NET Framework use:</strong></p>
             <p>We have investigated compression scenarios for a bunch of different frequently occurring compression data and found that in all
             cases we investigated so far, <code>DefaultStrategy</code> provided best results</p>
             <p>See also: How to choose a compression level (in comments to <code>CompressionLevel</code>.</p>
             </summary>
        </member>
        <member name="T:ConMaster.Compression.CompressionMethod">
            <summary>
            In version 1.2.3, ZLib provides on the <code>Deflated</code>-<code>CompressionMethod</code>.
            </summary>
        </member>
        <member name="T:ConMaster.Compression.ZStream">
            <summary>
            ZLib stream descriptor data structure
            Do not construct instances of <code>ZStream</code> explicitly.
            Always use <code>ZLibNative.DeflateInit2_</code> or <code>ZLibNative.InflateInit2_</code> instead.
            Those methods will wrap this structure into a <code>SafeHandle</code> and thus make sure that it is always disposed correctly.
            </summary>
        </member>
        <member name="F:ConMaster.Compression.ZLibInterop.Deflate_DefaultWindowBits">
            <summary>
            <p><strong>From the ZLib manual:</strong></p>
            <p>ZLib's <code>windowBits</code> parameter is the base two logarithm of the window size (the size of the history buffer).
            It should be in the range 8..15 for this version of the library. Larger values of this parameter result in better compression
            at the expense of memory usage. The default value is 15 if deflateInit is used instead.<br /></p>
            <strong>Note</strong>:
            <code>windowBits</code> can also be -8..-15 for raw deflate. In this case, -windowBits determines the window size.
            <code>Deflate</code> will then generate raw deflate data with no ZLib header or trailer, and will not compute an adler32 check value.<br />
            <p>See also: How to choose a compression level (in comments to <code>CompressionLevel</code>.</p>
            </summary>
        </member>
        <member name="F:ConMaster.Compression.ZLibInterop.ZLib_DefaultWindowBits">
            <summary>
            <p><strong>From the ZLib manual:</strong></p>
            <p>ZLib's <code>windowBits</code> parameter is the base two logarithm of the window size (the size of the history buffer).
            It should be in the range 8..15 for this version of the library. Larger values of this parameter result in better compression
            at the expense of memory usage. The default value is 15 if deflateInit is used instead.<br /></p>
            </summary>
        </member>
        <member name="F:ConMaster.Compression.ZLibInterop.GZip_DefaultWindowBits">
            <summary>
            <p>Zlib's <code>windowBits</code> parameter is the base two logarithm of the window size (the size of the history buffer).
            For GZip header encoding, <code>windowBits</code> should be equal to a value between 8..15 (to specify Window Size) added to
            16. The range of values for GZip encoding is therefore 24..31.
            <strong>Note</strong>:
            The GZip header will have no file name, no extra data, no comment, no modification time (set to zero), no header crc, and
            the operating system will be set based on the OS that the ZLib library was compiled to. <code>ZStream.adler</code>
            is a crc32 instead of an adler32.</p>
            </summary>
        </member>
        <member name="F:ConMaster.Compression.ZLibInterop.Deflate_DefaultMemLevel">
            <summary>
            <p><strong>From the ZLib manual:</strong></p>
            <p>The <code>memLevel</code> parameter specifies how much memory should be allocated for the internal compression state.
            <code>memLevel</code> = 1 uses minimum memory but is slow and reduces compression ratio; <code>memLevel</code> = 9 uses maximum
            memory for optimal speed. The default value is 8.</p>
            <p>See also: How to choose a compression level (in comments to <code>CompressionLevel</code>.</p>
            </summary>
        </member>
    </members>
</doc>
